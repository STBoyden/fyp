// Code generated by go generate; DO NOT EDIT

package tiles

import (
	"image"

	"fyp/src/common/ctypes"

	"github.com/hajimehoshi/ebiten/v2"
)

// Sprites from "resources/images/tilemap.png"

type Tiles struct{
	
	Space space
	
	Ground ground
	
	Coin coin
	
	Diamond diamond
	
	Heart heart
	
	Spike spike
	
	Door door
	
}

func Initialise(sheet *ctypes.Spritesheet) Tiles {

	var _space space
	_space.init(sheet)

	var _ground ground
	_ground.init(sheet)

	var _coin coin
	_coin.init(sheet)

	var _diamond diamond
	_diamond.init(sheet)

	var _heart heart
	_heart.init(sheet)

	var _spike spike
	_spike.init(sheet)

	var _door door
	_door.init(sheet)


	return Tiles{
		
		Space: _space,
		
		Ground: _ground,
		
		Coin: _coin,
		
		Diamond: _diamond,
		
		Heart: _heart,
		
		Spike: _spike,
		
		Door: _door,
		
	}
}

func (tiles *Tiles) StepAnimateTiles() {






	tiles.Coin.StepAnimation()



	tiles.Diamond.StepAnimation()



	tiles.Heart.StepAnimation()






}



type space struct{
	image *ebiten.Image
}

func (t *space) init(sheet *ctypes.Spritesheet) {
	s, err := sheet.Sheet()
	if err != nil {
		panic("couldn't init Space sprites: " + err.Error())
	}

	if subimage, ok := s.SubImage(image.Rect(0, 0, 16, 16)).(*ebiten.Image); ok && subimage != nil {
		t.image = subimage
	}
}

func (t *space) Draw(screen *ebiten.Image, x, y float64) {
	op := &ebiten.DrawImageOptions{}
	op.GeoM.Translate(x, y)

	screen.DrawImage(t.image, op)
}



type ground struct {
	ul *ebiten.Image
	um *ebiten.Image
	ur *ebiten.Image
	ml *ebiten.Image
	mm *ebiten.Image
	mr *ebiten.Image
	bl *ebiten.Image
	bm *ebiten.Image
	br *ebiten.Image
	
}

func (t *ground) init(sheet *ctypes.Spritesheet) {
	s, err := sheet.Sheet()
	if err != nil {
		panic("couldn't init Ground sprites: " + err.Error())
	}

	
	if subimage, ok := s.SubImage(image.Rect(112, 64, 128, 80)).(*ebiten.Image); ok && subimage != nil {
		t.ul = subimage
	}
	
	if subimage, ok := s.SubImage(image.Rect(128, 64, 144, 80)).(*ebiten.Image); ok && subimage != nil {
		t.um = subimage
	}
	
	if subimage, ok := s.SubImage(image.Rect(144, 64, 160, 80)).(*ebiten.Image); ok && subimage != nil {
		t.ur = subimage
	}
	
	if subimage, ok := s.SubImage(image.Rect(112, 80, 128, 96)).(*ebiten.Image); ok && subimage != nil {
		t.ml = subimage
	}
	
	if subimage, ok := s.SubImage(image.Rect(128, 80, 144, 96)).(*ebiten.Image); ok && subimage != nil {
		t.mm = subimage
	}
	
	if subimage, ok := s.SubImage(image.Rect(144, 80, 160, 96)).(*ebiten.Image); ok && subimage != nil {
		t.mr = subimage
	}
	
	if subimage, ok := s.SubImage(image.Rect(112, 96, 128, 112)).(*ebiten.Image); ok && subimage != nil {
		t.bl = subimage
	}
	
	if subimage, ok := s.SubImage(image.Rect(128, 96, 144, 112)).(*ebiten.Image); ok && subimage != nil {
		t.bm = subimage
	}
	
	if subimage, ok := s.SubImage(image.Rect(144, 96, 160, 112)).(*ebiten.Image); ok && subimage != nil {
		t.br = subimage
	}
	
}

func (t *ground) DrawUL(screen *ebiten.Image, x, y float64) {
	op := &ebiten.DrawImageOptions{}
	op.GeoM.Translate(x, y)

	screen.DrawImage(t.ul, op)
}

func (t *ground) DrawUM(screen *ebiten.Image, x, y float64) {
	op := &ebiten.DrawImageOptions{}
	op.GeoM.Translate(x, y)

	screen.DrawImage(t.um, op)
}

func (t *ground) DrawUR(screen *ebiten.Image, x, y float64) {
	op := &ebiten.DrawImageOptions{}
	op.GeoM.Translate(x, y)

	screen.DrawImage(t.ur, op)
}

func (t *ground) DrawML(screen *ebiten.Image, x, y float64) {
	op := &ebiten.DrawImageOptions{}
	op.GeoM.Translate(x, y)

	screen.DrawImage(t.ml, op)
}

func (t *ground) DrawMM(screen *ebiten.Image, x, y float64) {
	op := &ebiten.DrawImageOptions{}
	op.GeoM.Translate(x, y)

	screen.DrawImage(t.mm, op)
}

func (t *ground) DrawMR(screen *ebiten.Image, x, y float64) {
	op := &ebiten.DrawImageOptions{}
	op.GeoM.Translate(x, y)

	screen.DrawImage(t.mr, op)
}

func (t *ground) DrawBL(screen *ebiten.Image, x, y float64) {
	op := &ebiten.DrawImageOptions{}
	op.GeoM.Translate(x, y)

	screen.DrawImage(t.bl, op)
}

func (t *ground) DrawBM(screen *ebiten.Image, x, y float64) {
	op := &ebiten.DrawImageOptions{}
	op.GeoM.Translate(x, y)

	screen.DrawImage(t.bm, op)
}

func (t *ground) DrawBR(screen *ebiten.Image, x, y float64) {
	op := &ebiten.DrawImageOptions{}
	op.GeoM.Translate(x, y)

	screen.DrawImage(t.br, op)
}




type coin struct{
	frames 			 []*ebiten.Image
	currentFrame int
	totalFrames	 int
}

func (t *coin) init(sheet *ctypes.Spritesheet) {
	frames := []*ebiten.Image{}
	s, err := sheet.Sheet()
	if err != nil {
		panic("couldn't init Coin sprites: " + err.Error())
	}

	
	if subimage, ok := s.SubImage(image.Rect(16, 0, 16, 16)).(*ebiten.Image); ok && subimage != nil {
		frames = append(frames, subimage)
	}
	
	if subimage, ok := s.SubImage(image.Rect(32, 0, 48, 16)).(*ebiten.Image); ok && subimage != nil {
		frames = append(frames, subimage)
	}
	

	t.frames = frames
	t.currentFrame = 0
	t.totalFrames = 2
}

func (t *coin) Draw(screen *ebiten.Image, x, y float64) {
	op := &ebiten.DrawImageOptions{}
	op.GeoM.Translate(x, y)

	screen.DrawImage(t.frames[t.currentFrame], op)
}

func (t *coin) StepAnimation() {
	if t.currentFrame < t.totalFrames {
		t.currentFrame++
	} else {
		t.currentFrame = 0
	}
}



type diamond struct{
	frames 			 []*ebiten.Image
	currentFrame int
	totalFrames	 int
}

func (t *diamond) init(sheet *ctypes.Spritesheet) {
	frames := []*ebiten.Image{}
	s, err := sheet.Sheet()
	if err != nil {
		panic("couldn't init Diamond sprites: " + err.Error())
	}

	
	if subimage, ok := s.SubImage(image.Rect(0, 16, 16, 32)).(*ebiten.Image); ok && subimage != nil {
		frames = append(frames, subimage)
	}
	
	if subimage, ok := s.SubImage(image.Rect(16, 16, 32, 32)).(*ebiten.Image); ok && subimage != nil {
		frames = append(frames, subimage)
	}
	
	if subimage, ok := s.SubImage(image.Rect(32, 16, 48, 32)).(*ebiten.Image); ok && subimage != nil {
		frames = append(frames, subimage)
	}
	

	t.frames = frames
	t.currentFrame = 0
	t.totalFrames = 3
}

func (t *diamond) Draw(screen *ebiten.Image, x, y float64) {
	op := &ebiten.DrawImageOptions{}
	op.GeoM.Translate(x, y)

	screen.DrawImage(t.frames[t.currentFrame], op)
}

func (t *diamond) StepAnimation() {
	if t.currentFrame < t.totalFrames {
		t.currentFrame++
	} else {
		t.currentFrame = 0
	}
}



type heart struct{
	frames 			 []*ebiten.Image
	currentFrame int
	totalFrames	 int
}

func (t *heart) init(sheet *ctypes.Spritesheet) {
	frames := []*ebiten.Image{}
	s, err := sheet.Sheet()
	if err != nil {
		panic("couldn't init Heart sprites: " + err.Error())
	}

	
	if subimage, ok := s.SubImage(image.Rect(0, 32, 16, 48)).(*ebiten.Image); ok && subimage != nil {
		frames = append(frames, subimage)
	}
	
	if subimage, ok := s.SubImage(image.Rect(16, 32, 32, 48)).(*ebiten.Image); ok && subimage != nil {
		frames = append(frames, subimage)
	}
	
	if subimage, ok := s.SubImage(image.Rect(32, 32, 48, 48)).(*ebiten.Image); ok && subimage != nil {
		frames = append(frames, subimage)
	}
	

	t.frames = frames
	t.currentFrame = 0
	t.totalFrames = 3
}

func (t *heart) Draw(screen *ebiten.Image, x, y float64) {
	op := &ebiten.DrawImageOptions{}
	op.GeoM.Translate(x, y)

	screen.DrawImage(t.frames[t.currentFrame], op)
}

func (t *heart) StepAnimation() {
	if t.currentFrame < t.totalFrames {
		t.currentFrame++
	} else {
		t.currentFrame = 0
	}
}



type spike struct{
	image *ebiten.Image
}

func (t *spike) init(sheet *ctypes.Spritesheet) {
	s, err := sheet.Sheet()
	if err != nil {
		panic("couldn't init Spike sprites: " + err.Error())
	}

	if subimage, ok := s.SubImage(image.Rect(48, 144, 64, 159)).(*ebiten.Image); ok && subimage != nil {
		t.image = subimage
	}
}

func (t *spike) Draw(screen *ebiten.Image, x, y float64) {
	op := &ebiten.DrawImageOptions{}
	op.GeoM.Translate(x, y)

	screen.DrawImage(t.image, op)
}



type door struct {
	closed *ebiten.Image
	opened *ebiten.Image
	
}

func (t *door) init(sheet *ctypes.Spritesheet) {
	s, err := sheet.Sheet()
	if err != nil {
		panic("couldn't init Door sprites: " + err.Error())
	}

	
	if subimage, ok := s.SubImage(image.Rect(256, 32, 272, 48)).(*ebiten.Image); ok && subimage != nil {
		t.closed = subimage
	}
	
	if subimage, ok := s.SubImage(image.Rect(288, 32, 304, 48)).(*ebiten.Image); ok && subimage != nil {
		t.opened = subimage
	}
	
}

func (t *door) DrawClosed(screen *ebiten.Image, x, y float64) {
	op := &ebiten.DrawImageOptions{}
	op.GeoM.Translate(x, y)

	screen.DrawImage(t.closed, op)
}

func (t *door) DrawOpened(screen *ebiten.Image, x, y float64) {
	op := &ebiten.DrawImageOptions{}
	op.GeoM.Translate(x, y)

	screen.DrawImage(t.opened, op)
}



