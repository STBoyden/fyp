package main

import (
	"flag"
	"fmt"
	"image"
	"io"
	"os"
	"strings"
	"text/template"

	"gopkg.in/yaml.v3"
)

func printErrorAndExit(format string, v ...any) {
	if v == nil {
		fmt.Fprintf(os.Stderr, format+"\n")
	} else {
		fmt.Fprintf(os.Stderr, format+"\n", v)
	}

	os.Exit(1)
}

type Bounds struct {
	X0 int `yaml:"x0" json:"x0"`
	Y0 int `yaml:"y0" json:"y0"`
	X1 int `yaml:"x1" json:"x1"`
	Y1 int `yaml:"y1" json:"y1"`
}

func (b Bounds) AsRect() image.Rectangle {
	return image.Rect(b.X0, b.Y0, b.X1, b.Y1)
}

type Variant struct {
	Suffix     string
	Bounds     Bounds
	Symbol     string
	Collidable bool
	Touchable  bool
}

func (v Variant) GetSuffix() string {
	return strings.ToLower(v.Suffix)
}

type Tile struct {
	Name       string    `yaml:"name" json:"name"`
	Frames     []Bounds  `yaml:"frames,omitempty" json:"frames,omitempty"`
	Bounds     *Bounds   `yaml:"bounds,omitempty" json:"bounds,omitempty"`
	Variants   []Variant `yaml:"variants,omitempty" json:"variants,omitempty"`
	Symbol     string    `yaml:"symbol,omitempty" json:"symbol,omitempty"`
	Collidable bool      `yaml:"collidable,omitempty" json:"collidable,omitempty"`
	Touchable  bool      `yaml:"touchable,omitempty" json:"touchable,omitempty"`
}

func (t Tile) GetName() string {
	return strings.ToLower(t.Name)
}

type Config struct {
	Sheet string
	Tiles []Tile
}

var tilesTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT

package tiles

import (
	"image"
	"time"

	"fyp/src/common/ctypes"

	"github.com/hajimehoshi/ebiten/v2"
)

// Sprites from "{{ .Sheet }}"

type Tiles struct{
	{{range $tile := .Tiles}}
	{{$tile.Name}} {{$tile.GetName}}
	{{end}}

	lastAnimated time.Time
}

func Initialise(sheet *ctypes.Spritesheet) Tiles {
{{range $tile := .Tiles}}
	var _{{$tile.GetName}} {{$tile.GetName}}
	_{{$tile.GetName}}.init(sheet)
{{end}}

	return Tiles{
		{{range $tile := .Tiles}}
		{{$tile.Name}}: _{{$tile.GetName}},
		{{end}}
	}
}

func (tiles *Tiles) StepAnimateTiles() {
	if time.Since(tiles.lastAnimated).Milliseconds() < 250 {
		return
	}
{{range $tile := .Tiles}}
{{if $tile.Frames}}
	tiles.{{$tile.Name}}.StepAnimation()
{{end}}
{{end}}

	tiles.lastAnimated = time.Now()
}

{{range $tile := .Tiles}}
{{if $tile.Variants }}
type {{$tile.GetName}} struct {
	{{range $variant := $tile.Variants}}{{$variant.GetSuffix}} *ebiten.Image
	{{end}}
}

func (t *{{$tile.GetName}}) init(sheet *ctypes.Spritesheet) {
	s, err := sheet.Sheet()
	if err != nil {
		panic("couldn't init {{$tile.Name}} sprites: " + err.Error())
	}

	{{range $variant := $tile.Variants}}
	if subimage, ok := s.SubImage(image.Rect({{$variant.Bounds.X0}}, {{$variant.Bounds.Y0}}, {{$variant.Bounds.X1}}, {{$variant.Bounds.Y1}})).(*ebiten.Image); ok && subimage != nil {
		t.{{$variant.GetSuffix}} = subimage
	}
	{{end}}
}
{{range $variant := $tile.Variants}}
func (t *{{$tile.GetName}}) Draw{{$variant.Suffix}}(screen *ebiten.Image, x, y float64) {
	op := &ebiten.DrawImageOptions{}
	op.GeoM.Translate(x, y)

	screen.DrawImage(t.{{$variant.GetSuffix}}, op)
}
{{end}}
{{else if $tile.Frames}}
type {{$tile.GetName}} struct{
	frames 			 []*ebiten.Image
	currentFrame int
	totalFrames	 int
}

func (t *{{$tile.GetName}}) init(sheet *ctypes.Spritesheet) {
	frames := []*ebiten.Image{}
	s, err := sheet.Sheet()
	if err != nil {
		panic("couldn't init {{$tile.Name}} sprites: " + err.Error())
	}

	{{range $frame := $tile.Frames}}
	if subimage, ok := s.SubImage(image.Rect({{$frame.X0}}, {{$frame.Y0}}, {{$frame.X1}}, {{$frame.Y1}})).(*ebiten.Image); ok && subimage != nil {
		frames = append(frames, subimage)
	}
	{{end}}

	t.frames = frames
	t.currentFrame = 0
	t.totalFrames = {{ len $tile.Frames }}
}

func (t *{{$tile.GetName}}) Draw(screen *ebiten.Image, x, y float64) {
	op := &ebiten.DrawImageOptions{}
	op.GeoM.Translate(x, y)

	screen.DrawImage(t.frames[t.currentFrame], op)
}

func (t *{{$tile.GetName}}) StepAnimation() {
	if t.currentFrame < t.totalFrames-1 {
		t.currentFrame++
	} else {
		t.currentFrame = 0
	}
}
{{else}}
type {{$tile.GetName}} struct{
	image *ebiten.Image
}

func (t *{{$tile.GetName}}) init(sheet *ctypes.Spritesheet) {
	s, err := sheet.Sheet()
	if err != nil {
		panic("couldn't init {{$tile.Name}} sprites: " + err.Error())
	}

	if subimage, ok := s.SubImage(image.Rect({{$tile.Bounds.X0}}, {{$tile.Bounds.Y0}}, {{$tile.Bounds.X1}}, {{$tile.Bounds.Y1}})).(*ebiten.Image); ok && subimage != nil {
		t.image = subimage
	}
}

func (t *{{$tile.GetName}}) Draw(screen *ebiten.Image, x, y float64) {
	op := &ebiten.DrawImageOptions{}
	op.GeoM.Translate(x, y)

	screen.DrawImage(t.image, op)
}
{{end}}
{{end}}
`))

var enumsTemplate = template.Must(template.New("").Parse(strings.ReplaceAll(`// Code generated by go generate; DO NOT EDIT

package tiles

type types int // Symbol[string],Collidable[bool],Touchable[bool]

//revive:disable:var-naming
//go:generate goenums tile_types.go
const ({{range $i, $tile := .Tiles }}
	{{if not $tile.Variants }}
	{{$tile.GetName}}_tile{{if (eq $i 0)}} types = iota{{end}} // ¬{{$tile.Symbol}}¬,{{$tile.Collidable}},{{$tile.Touchable}}
	{{else if $tile.Variants}}
	{{range $variant := $tile.Variants}}
	{{$tile.GetName}}_{{$variant.GetSuffix}}_tile{{if (eq $i 0)}} types = iota{{end}} // ¬{{$variant.Symbol}}¬,{{$variant.Collidable}},{{$variant.Touchable}}
	{{end}}
	{{end}}
	{{end}}
)
`, "¬", "`")))

func main() {
	var filePath string

	flag.StringVar(&filePath, "f", "", "Specify spritesheet data file path, must be in YAML format.")
	flag.Parse()

	if filePath == "" {
		printErrorAndExit("given file path should not be empty")
	}

	file, err := os.Open(filePath)
	if err != nil {
		printErrorAndExit("error occurred when trying to open spritesheet data file: %s", err)
	}
	defer file.Close()

	info, err := file.Stat()
	if err != nil {
		printErrorAndExit("given file path could not be stat'd: %s", err)
	}

	if info.IsDir() {
		printErrorAndExit("provided file path is a directory, needs to be a file")
	}

	buffer, err := io.ReadAll(file)
	if err != nil {
		printErrorAndExit("could not read file: %s", err)
	}

	var config Config
	err = yaml.Unmarshal(buffer, &config)
	if err != nil {
		printErrorAndExit("could not parse yaml file: %s", err)
	}

	outFile, err := os.Create("tiles/tiles.go")
	if err != nil {
		printErrorAndExit("could output spritesheet tile data to go file: %s", err)
	}

	err = tilesTemplate.Execute(outFile, config)
	if err != nil {
		printErrorAndExit("error occurred when attempting to output spritesheet tile data to go file: %s", err)
	}

	outFile, err = os.Create("tiles/tile_types.go")
	if err != nil {
		printErrorAndExit("could output spritesheet tile data to go file: %s", err)
	}

	err = enumsTemplate.Execute(outFile, config)
	if err != nil {
		printErrorAndExit("error occurred when attempting to output spritesheet tile enum data to go file: %s", err)
	}
}
